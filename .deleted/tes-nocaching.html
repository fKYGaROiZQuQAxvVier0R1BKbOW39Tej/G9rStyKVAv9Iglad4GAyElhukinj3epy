<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    @font-face {
      font-family: 'ByteBounce';
      src: url('ByteBounce_modified.ttf') format('truetype');
    }

    body {
      margin: 0;
      height: 100vh;
      background-color: #5d7388;
      overflow: hidden;
    }

    #stage {
      position: absolute;
      top: 0;
      height: 100vh;
      width: auto;
      left: 50%;
      transform: translateX(-50%);
      overflow: hidden;
    }

    #layers {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .layer {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .layer-inner {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      pointer-events: none;
      transform: translate(0, 0);
      /* will-change: transform; */
    }

    .layer canvas {
      image-rendering: pixelated;
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: auto;
      pointer-events: none;
      transform: translate(0, 0);
      /* will-change: transform; */
    }

    .time-text {
      position: absolute;
      font-family: 'ByteBounce', monospace;
      color: white;
      font-size: 48px;
      left: 50%;
      top: 30%;
      transform: translate(-50%, 0);
      z-index: 1000;
      line-height: 1.2;
      white-space: nowrap;
      text-align: center;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="stage">
    <div id="layers"></div>
    <div class="time-text">:<br>Friday</div>
  </div>

  <script>
    //#region GLOBALS

    const _stage = document.getElementById('stage')
    const _layersContainer = document.getElementById('layers')
    const _layers = []

    let _zIndex = 0
    let _stageHeight = 0
    let _baseSet = false
    let NOW = 0

    //#endregion GLOBALS



    //#region HELPER FUNCTIONS

    function _tintCanvas(canvas, image, r, g, b) {
      const ctx = canvas.getContext('2d')
      canvas.width = image.naturalWidth
      canvas.height = image.naturalHeight
      ctx.imageSmoothingEnabled = false
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.drawImage(image, 0, 0)
      
      if (r !== 255 || g !== 255 || b !== 255) {
        ctx.globalCompositeOperation = 'multiply'
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.globalCompositeOperation = 'destination-in'
        ctx.drawImage(image, 0, 0)
      }
      
      ctx.globalCompositeOperation = 'source-over'
    }

    //#endregion HELPER FUNCTIONS



    //#region STAGE MANAGEMENT

    function _resizeStage() {
      _stageHeight = _stage.getBoundingClientRect().height
      _layers.forEach(layer => layer._resize())
    }

    function _setupStage() {
      new ResizeObserver(_resizeStage).observe(_stage)
      window.addEventListener('resize', _resizeStage)
    }

    //#endregion STAGE MANAGEMENT



    //#region TWEENER CLASS

    class Tweener {
      constructor() {
        this.tweens = []
      }

      _ease(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
      }

    tween(target, property, toValue, duration) {
        this.tweens = this.tweens.filter(t => !(t.target === target && t.property === property))
        
        if (duration === 0) {
          target[property] = toValue
          return
        }
        
        this.tweens.push({
          target,
          property,
          fromValue: target[property],
          toValue,
          elapsed: 0,
          duration
        })
      }

      _process(delta) {
        for (let i = this.tweens.length - 1; i >= 0; i--) {
          const tween = this.tweens[i]
          tween.elapsed += delta
          
          if (tween.elapsed >= tween.duration) {
            tween.target[tween.property] = tween.toValue
            this.tweens.splice(i, 1)
          } else {
            const t = tween.elapsed / tween.duration
            const eased = this._ease(t)
            tween.target[tween.property] = tween.fromValue + (tween.toValue - tween.fromValue) * eased
          }
        }
      }
    }

    const _tweener = new Tweener()

    //#endregion TWEENER CLASS



    //#region ANIMATION LOOP

    let _lastTime = performance.now()

    function _process() {
      const time = performance.now()
      const delta = Math.min(0.05, (time - _lastTime) / 1000)
      _lastTime = time
      NOW = time

      _tweener._process(delta)
      _layers.forEach(layer => layer._process(delta))

      requestAnimationFrame(_process)
    }

    //#endregion ANIMATION LOOP



    //#region LAYER CLASS

    class Layer {
      constructor(imagePath) {
        this.wrapper = document.createElement('div')
        this.wrapper.className = 'layer'
        this.wrapper.style.zIndex = _zIndex++
        _layersContainer.appendChild(this.wrapper)

        this.inner = document.createElement('div')
        this.inner.className = 'layer-inner'
        this.wrapper.appendChild(this.inner)

        this.image = new Image()
        this.canvases = []
        
        this.offsetX = 0
        this.offsetY = 0
        this.opacity = 1
        this.speed = 0
        this.colorR = 255
        this.colorG = 255
        this.colorB = 255

        this.scrollOffset = 0
        this.scale = 1
        this.width = 0
        this.built = false
        
        this._createCanvases()
        
        this.image.onload = () => this._build()
        this.image.src = imagePath
        _layers.push(this)
      }

      _createCanvases() {
        for (let i = 0; i < 2; i++) {
          const canvas = document.createElement('canvas')
          this.inner.appendChild(canvas)
          this.canvases.push(canvas)
        }
      }

      setOffset(x = 0, y = 0, duration = 0) {
        _tweener.tween(this, 'offsetX', x, duration)
        _tweener.tween(this, 'offsetY', y, duration)
        return this
      }

      setOpacity(value, duration = 0) {
        _tweener.tween(this, 'opacity', Math.max(0, Math.min(1, value)), duration)
        return this
      }

      setColor(r, g, b, duration = 0) {
        _tweener.tween(this, 'colorR', r, duration)
        _tweener.tween(this, 'colorG', g, duration)
        _tweener.tween(this, 'colorB', b, duration)
        return this
      }

      setSpeed(speed, duration = 0) {
        _tweener.tween(this, 'speed', speed === null ? 0 : speed, duration)
        return this
      }

      resetOffset(duration = 0) { return this.setOffset(0, 0, duration) }
      resetOpacity(duration = 0) { return this.setOpacity(1, duration) }
      resetSpeed(duration = 0) { return this.setSpeed(0, duration) }
      resetColor(duration = 0) { return this.setColor(255, 255, 255, duration) }

      _resize() {
        if (!_stageHeight || !this.image.naturalHeight) return
        
        this.scale = _stageHeight / this.image.naturalHeight
        this.width = this.image.naturalWidth * this.scale
        this.wrapper.style.width = this.width + 'px'
        this.canvases.forEach(c => c.style.width = this.width + 'px')
        
        this._positionScrollTiles()
      }

      _positionScrollTiles() {
        const nw = this.image.naturalWidth
        const normalizedOffset = (((this.scrollOffset % nw) + nw) % nw)
        const shift = normalizedOffset * this.scale
        
        this.canvases[0].style.transform = `translate(${-shift}px, 0)`
        this.canvases[1].style.transform = `translate(${this.width - shift}px, 0)`
      }

      _process(dt) {
        if (!this.built) return

        this.wrapper.style.opacity = this.opacity
        this.inner.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px, 0)`
        
        const r = Math.round(this.colorR)
        const g = Math.round(this.colorG)
        const b = Math.round(this.colorB)
        this.canvases.forEach(c => _tintCanvas(c, this.image, r, g, b))

        if (this.speed !== 0) {
          this.scrollOffset -= this.speed * dt
          this._positionScrollTiles()
        }
      }

      _build() {
        if (this.built) return
        this.built = true

        if (!_baseSet) {
          _baseSet = true
          _stage.style.aspectRatio = `${this.image.naturalWidth} / ${this.image.naturalHeight}`
          requestAnimationFrame(_resizeStage)
        }

        this.wrapper.style.opacity = this.opacity
        this.inner.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px)`

        const r = Math.round(this.colorR)
        const g = Math.round(this.colorG)
        const b = Math.round(this.colorB)
        this.canvases.forEach(c => _tintCanvas(c, this.image, r, g, b))
        
        this._resize()
        this._positionScrollTiles()
      }
    }

    //#endregion LAYER CLASS



    //#region INITIALIZATION

    _setupStage()
    _resizeStage()

    let sky = new Layer("sky.png").setColor(251, 204, 186)
    let medium_clouds = new Layer("medium_clouds.png").setColor(0, 0, 255).setSpeed(3)
    let big_clouds = new Layer("big_clouds.png").setColor(255, 0, 0).setSpeed(1.5)
    let buildings = new Layer("buildings.png")
    let foreground = new Layer("foreground.png")
    let raycasts = new Layer("raycasts.png").setColor(255, 173, 139)
    let papers = new Layer("papers.png")
    
    _process()

    //#endregion INITIALIZATION
  </script>
</body>
</html>